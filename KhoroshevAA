# Инструкция по работе с MarkDown

## Выделение текста

Язык разметки Markdown поддерживает 2 стиля обозначения заголовков: подчеркивание и выделение символом («#»). 

Выделение заголовков с помощью подчеркивания производится знаками равенства («=») в случае, если заголовок первого уровня, и дефисами («-») в случае, если заголовок второго уровня. Количество знаков подчеркивания не ограничивается. При выделении заголовков с помощью символа («#») используется от одного до шести данных символов, которые устанавливаются в начале строки (перед заголовком). В данном случае количество символов соответствует уровню заголовка. Кроме того, заголовок возможно снабдить закрывающимися символами («#»), хотя это и не является обязательным. Количество закрывающихся символов не обязано соответствовать количеству начальных символов. Уровень заголовка определяется по количеству начальных символов.

Чтобы задать для текста полужирное начертание, заключите его в двойные звездочки (**) или в двойные знаки нижнего подчеркивания (__):

Этот текст выделен **жирным**

Чтобы задать для текста курсивное начертание, заключите его в одинарные звездочки (*) или нижнее подчеркивание (_):

Этот текст выделен *курсивом*

Чтобы задать для текста полужирное и курсивное начертание, заключите его в тройные звездочки (***) или тройные знаки нижнего подчеркивания (___):

Этот текст выделен ***жирным и курсивом***

Альтернативные способы выделения текста жирным или курсивом нужны для того, чтобы была возможность совмещения двух этих способов.

Например:

__Этот текст может быть выделен как жирным так и *одновременно жирным и курсивом*, причем в любой части *предложения*__

## Списки


Markdown поддерживает упорядоченные (нумерованные) и неупорядоченные (ненумерованные) списки. Для формирования неупорядоченный списков используются такие маркеры, как звездочки, плюсы и дефисы. Все перечисленные маркеры могут использоваться взаимозаменяемо. Для формирования упорядоченных списков в качестве маркеров используются числа с точкой. Важной особенностью в данном случае является то, что сами номера, с помощью которых формируется список, не важны, так как они не оказывают влияния на выходной код. Как бы ни нумеровал пользователь список, на выходе он в любом случае будет иметь упорядоченный список, начинающийся с единицы (1, 2, 3…). Эту особенность стоит учитывать в том случае, когда необходимо использовать порядковые номера элементов в списке, чтобы они соответствовали номерам, получающимся в HTML. Упорядоченные списки всегда следует начинать с единицы. Маркеры списков обычно начинаются с начала строки, однако они могут быть сдвинуты, но не более чем на 3 пробела. За маркером должен следовать пробел, либо символ табуляции. При необходимости в список можно вставить цитату. В этом случае обозначения цитирования ( «>» ) нужно писать с отступом.

Упорядоченные списки выглядят следующим образом:

        1.	Проводник
        2.	Полупроводник
        3.	Диэлектрик

Неупорядоченные списки выглядят следующим образом:

        * Проводник
        * Полупроводник
        * Диэлектрик

Или

        - Проводник
        - Полупроводник
        - Диэлектрик

Или

        + Проводник
        + Полупроводник
        + Диэлектрик   

На выходе всех трех перечисленных вариантов имеется один и тот же результат. В результате на экран выводится следующее:

1.	Проводник
2.	Полупроводник
3.	Диэлектрик

и

* Проводник
* Полупроводник
* Диэлектрик

Соответственно для создания уровней списков необходимо использовать табуляцию.

## Работа с изображениями

Для добавления изображения в текст необъодимо набрать команду следующего вида:

! [Картинка alt] (адрес картинки "заголовок картинки")

где

1. alt изображения - это текст, отображаемый под изображением, который эквивалентен объяснению содержания изображения.
2. Название изображения - это название изображения, содержимое которого отображается при наведении курсора мыши.

Например:

![тестовое_изображение](123.jpg)

## Ссылки

Чтобы поставить гиперссылку без анкора, нужно взять URL в угловые скобки. С e-mail – аналогично.

Если вставлять с анкором, то тогда текст ссылки заключается в квадратные скобки, а адрес страницы – в круглые. Рядом с URL можно прописать тайтл, его объявляют в кавычках (он тоже остается внутри круглых скобок).

Это [ссылка](https://github.com/) с тайтлом.

[Эта ссылка](https://github.com/) без заголовка.

<https://github.com/> – а это безанкорная ссылка.

## Цитаты

Если безанкорные ссылки оформляются двумя угловыми скобками, то для цитаты нужна только одна такая скобка. Все очень просто:

> Привет! Это цитата

> Это тоже цитата


> Это еще одна цитата.
Это ее продолжение (показываем отступом)


> Это тоже
Будет
> Одна целая цитата

# Инструкция по работе с операторами GIT

## Проверка установки:

git --version

## Справка:

git help
git help [command-name]
git [command-name] --help | -h

## Минимальные настройки:

// --local - настройки для текущего репо
// --global - настройки для текущего пользователя
// --system - настройки для всей системы, т.е. для всех пользователей
git config --global user.name "My Name"
git config --global user.email "myemail@example.com"

## Дополнительные настройки:

// список глобальных настроек
git config --list | -l --global

// редактирование глобальных настроек
git config --global --edit | -e

## Создание репозитория:

git init

## Очистка репозитория:

// -d - включая директории, -x - включая игнорируемые файлы, -f - принудительная
git clean | -dxf

## Удаление файлов и директорий:

// remove
git rm [file-name]
git rm -r [dir-name]

git rm --force | -f

## Перемещение файлов:

// git add + git remove
// move
git mv [old-file] [new-file]

## Просмотр состояния репозитория:

git status

## Добавление изменений:

git add [file-name]

git add --force | -f

// все файлы
git add . | --all | -A

// для добавления пустой директории можно создать в ней пустой файл .gitkeep

## Добавление сообщения (коммита):

// редактирование коммита


git commit

// коммит для одного изменения, если не выполнялось 

git add . | -A


// если выполнялось, сообщение будет добавлено для всех изменений


git commit --message | -m "My Message"

// для всех изменений, если git add [file-name] выполнялось несколько раз


git commit --all | -a -m | -am "My Message"

// исправление коммита

git commit --amend "My Message" | --no-edit

## Просмотр коммита:

// последний коммит


git show

// другой коммит

git show [hash] // минимум первые 4 символа

// поиск изменений по сообщению или части сообщения

git show :/[string]

// поиск коммита по тегу

git show [tag-name]

## Просмотр разницы между коммитами:

git diff HEAD | @ // HEAD - как правило, текущая ветка; @ - алиас для HEAD

// staged

git diff --staged | --cached

git diff [hash1] [hash2]

// разница между ветками

git diff [branch1]...[branch2]

// просмотр разницы между коммитами при редактировании сообщения

git commit --verbose | -v

// кастомизация выводимого сообщения

git diff --word-diff | --color-words

## Просмотр истории изменений:

git log

// n - количество изменений

git log -n

// --since, --after - после

// --until, --before - до

// разница

git log -p

// быстрое форматирование

git log --graph --oneline --stat

// кастомное форматирование

git log --pretty=format

// пример

git log --pretty=format:'%C(red)%h %C(green)%cd %C(reset)| %C(blue)%s%d %C(yellow)[%an]' --date=short | format-local:'%F %R'

// поиск изменений по слову, файлу, ветке; i - без учета регистра

git log --grep | -G [string] | [file] | [branch] & -i

// поиск по нескольким строкам

git log --grep [string1] --grep [string2] --all-match

// поиск в определенном блоке файла

git log -L '/<head>/','/<\/head>/':index.html

// поиск по автору

git log --author=[name]

## Отмена изменений:

git reset

// --hard - включая рабочую директорию и индекс

// --soft - без рабочей директории и индекса

// --mixed - по умолчанию: без рабочей директории, но с индексом

git reset --hard [hash] | @~ // @~ - последний коммит в HEAD

// аналогично

git reset --hard ORIG_HEAD

// не путать с переключением ветки

git checkout

git restore

## Работа с ветками:

// список веток

git branch

// создание ветки

git branch [branch-name]

// переключение на ветку

git checkout [branch-name]

// branch + checkout

git checkout -b [branch-name]

// переименование

git branch -m [old-branch] [new-branch]

// удаление ветки

git branch -d [branch-name]

// слияние веток

git merge [branch-name]

## Разрешение конфликтов при слиянии:

// обычно, при возникновении конфликта, открывается редактор

// принять изменения из сливаемой ветки

git checkout --ours

// принять изменения из текущей ветки

git checkout --theirs

// отмена слияния

git reset --merge

git merge --abort

// получение дополнительной информации

git checkout --conflict=diff3 --merge [file-name]

// продолжить слияние

git merge --continue

## Удаленный репозиторий:

// клонирование

git clone [url] & [dir]

// просмотр

git remote

git remote show

git remote add [shortname] [url]

git remote rename [old-name] [new-name]

// получение изменений

// git fetch + git merge

git pull

// отправка изменений

git push

# Работа с удаленными репозиториями

## Git clone

git clone url_путь_к_проекту

Делает клон(копию) удаленного репозитория. Копия сделается на вашем компьютере по текущему пути.

Пример:

                git clone https://github.com/Example/Example.js

Описание примера

После git clone команды появится новый каталог в котором находится копия удаленного репозитория.
В новом репозитории, можем смотреть историю, кто и когда вносил изменения.

Если запустим команду git remote -v то увидим url адрес удаленного репозитория с которыми мы работаем.

В нашем примере мы работаем с одним удаленным репозиторием, которому присвоено короткое имя по умолчанию origin и находится по адресу https://github.com/Example/Example.js

## Git push

                git push <remote> <branch>

Публикация указанной ветки в удаленном репозитории вместе со всеми необходимыми коммитами и внутренними объектами. Эта команда создает локальную ветку в репозитории назначения. Чтобы предотвратить перезапись коммитов, Git не позволит опубликовать данные, если в репозитории назначения нельзя выполнить ускоренное слияние.

                git push <remote> --force

Аналогично приведенной выше команде, однако данные будут опубликованы принудительно, даже если нельзя выполнить ускоренное слияние. Не используйте флаг --force, если вы не уверены в своих действиях.

                git push <remote> --all

Публикация всех локальных веток в указанном удаленном репозитории.

                git push <remote> --tags

При публикации ветки или использовании опции --all теги не публикуются автоматически. Флаг --tags отправляет все локальные теги в удаленный репозиторий.

Команда git push чаще всего используется для публикации выгружаемых локальных изменений в центральном репозитории. Для того чтобы поделиться изменениями, внесенными в локальный репозиторий, с удаленными участниками команды, необходимо выполнить команду push.

## Git pull

                git pull <remote>

Извлечь из указанного удаленного репозитория копию текущей ветки и немедленно слить ее с локальной копией. Эта команда аналогична команде **git fetch <удаленный-репозиторий>**, после которой следует команда **git merge origin/<текущая-ветка>**.

                git pull --no-commit <remote>
Подобно вызову по умолчанию, извлекает удаленное содержимое, но не создает новый коммит со слитым содержимым.

                git pull --rebase <remote>
Аналогично предыдущей команде **pull**, только вместо команды **git merge** для интеграции удаленной ветки с локальной веткой используется команда **git rebase**.

                git pull --verbose
Во время выполнения команды **pull** выдает подробный вывод о загружаемом содержимом и информацию о слиянии.

Команду **git pull** можно представить как версию команды svn update, только применимую в системе Git. Это простой способ синхронизировать локальный репозиторий с вышестоящими изменениями.

Сначала вы думаете, что ваш репозиторий синхронизирован, однако команда **git fetch** показывает, что с момента последней проверки версия origin ветки main была изменена. Затем команда **git merge** сразу интегрирует удаленную ветку main в локальную ветку.